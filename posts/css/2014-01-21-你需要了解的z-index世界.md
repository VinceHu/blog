## 你需要了解的z-index世界

## z-index的重要性

在我看来，`z-index` 给了我们日常工作中以极大的帮助，我们用它来定义元素的层叠级别（stack level）。受益于它，你能做Popup, DropDown, Tips, 图文替换等等。

在开始本篇之前，或许我们要先了解一下关于z-index的基本信息。

## W3C这样描述

每个元素都具有三维空间位置，除了水平和垂直位置外，还能在 "Z轴" 上层层相叠、排列。元素在 "Z轴" 方向上的呈现顺序，由层叠上下文和层叠级别决定。

在文档中，每个元素仅属于一个层叠上下文。元素的层叠级别为整型，它描述了在相同层叠上下文中元素在 "Z轴" 上的呈现顺序。

同一层叠上下文中，层叠级别大的显示在上，层叠级别小的显示在下，相同层叠级别时，遵循后来居上的原则，即其在HTML文档中的顺序。

不同层叠上下文中，元素呈现顺序以父级层叠上下文的层叠级别来决定呈现的先后顺序，与自身的层叠级别无关。

<!--more-->

## z-index语法和应用

    z-index: auto | <integer>

`z-index` 接受的属性值为：关键字auto和整数，整数可以是负值（Firefox2.0及之前不支持负值）。

需要注意的是 `z-index` 虽然很给力，却只能应用于定位元素（即设置了 `position` 属性为非 `static` 值），其它情况下，`z-index` 将被忽略。

对于定位元素而言，`z-index` 意味着：

* 确定该元素在当前层叠上下文中的层叠级别。
* 确定该元素是否创建了一个新的局部层叠上下文。

## 创建层叠上下文

在规范中说明：当某个元素的 `z-index` 未显式定义或者被指定为 `auto` 时，该元素不会产生新的局部层叠上下文。也就是说它可以和兄弟，祖先，后辈元素处在同一个堆叠上下文中，它们被放在一起比较层叠级别，儿子可以盖住祖先，父亲也可以盖住儿子，儿子甚至可以越过祖先，盖住祖先的兄弟，在堆叠上下文中，它们是并级的关系。来看这样一个例子 `DEMO1`: [z-index与创建层叠上下文](http://demo.doyoe.com/css/z-index/stacking-context.htm)

值得高兴的是，大部分浏览器都实现了这个特性；不过在IE6/7下，不论 `z-index` 值是否被显式定义，都将产生局部层叠上下文，也就是说子元素不可以超过父亲，子元素都处在新创建的局部层叠上下文中，只能在内部进行层叠级别的比较。这也就是在IE6/7下常出现覆盖Bug的根源。

## 你遇见这样的场景

某区域内有个浮层提示或者下拉菜单，于是需要遮住该区域之下的区域。

### HTML

    <div class="a">
        ...
        <div class="tips">我是一个简陋的浮层提示</div>
    </div>
    <div class="b">
        ...
    </div>

### CSS

    .a{position:relative;}
    .tips{position:absolute;z-index:99;}

如上HTML/CSS代码，很显然，浮层 `tips` 将可以覆盖在其父级元素 `a` 的兄弟元素 `b` 之上，因为 `tips` 的层叠级别 `z-index` 为99。

然而，有些情况可能是你没注意或者已然存在的。比如你事先可能并不知道 `b` 也是定位元素，或者由于某些原因，你主动将其设置为定位元素。于是CSS变成这样：

### CSS

    .a{position:relative;}
    .tips{position:absolute;z-index:99;}
    .b{position:relative;}

这段代码run完之后，你能得到纠结的效果，如下 `图一`：

![IE6/7 create stacking context bug](http://demo.doyoe.com/css/z-index/images/create-stacking-context-ie6-7-bug.png)（图一）

待续。。。